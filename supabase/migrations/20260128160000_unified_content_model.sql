-- Unified Content Model Migration
-- Replaces cp_content_ideas, cp_content_briefs, cp_content_items with single cp_content table

-- ============================================================================
-- STEP 0: Drop dependent objects that reference columns we'll alter
-- ============================================================================

-- Drop view that depends on cp_author_assignments.content_item_id
DROP VIEW IF EXISTS cp_author_workload CASCADE;

-- Drop policy that depends on cp_author_assignments.content_item_id
DROP POLICY IF EXISTS "Authors can update assigned content items" ON cp_content_items;

-- ============================================================================
-- STEP 1: Create the unified cp_content table
-- ============================================================================

CREATE TABLE cp_content (
  -- Core fields
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  slug VARCHAR(500),
  description TEXT, -- From ideas.description / briefs.summary

  -- Stage tracking
  stage VARCHAR(20) NOT NULL DEFAULT 'idea' CHECK (stage IN ('idea', 'brief', 'content')),

  -- Stage-specific status fields
  idea_status VARCHAR(50) CHECK (idea_status IN ('submitted', 'under_review', 'approved', 'rejected', 'converted')),
  brief_status VARCHAR(50) CHECK (brief_status IN ('draft', 'ready', 'assigned', 'in_progress', 'completed')),
  workflow_status_id BIGINT REFERENCES cp_workflow_statuses(id) ON DELETE SET NULL,

  -- Common fields
  content_type_id BIGINT REFERENCES cp_content_types(id) ON DELETE SET NULL,
  campaign_id BIGINT REFERENCES cp_campaigns(id) ON DELETE SET NULL,
  priority VARCHAR(20) DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
  notes TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,

  -- Idea-specific fields
  source VARCHAR(100), -- Where the idea came from
  potential_keywords JSONB DEFAULT '[]'::jsonb,
  target_audience TEXT,
  estimated_effort VARCHAR(20) CHECK (estimated_effort IN ('low', 'medium', 'high')),
  vote_count INTEGER DEFAULT 0,
  votes JSONB DEFAULT '[]'::jsonb,
  rejection_reason TEXT,
  submitted_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  reviewed_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  reviewed_at TIMESTAMPTZ,

  -- Brief/SEO fields
  primary_keyword VARCHAR(500),
  secondary_keywords JSONB DEFAULT '[]'::jsonb,
  search_intent VARCHAR(100),
  target_word_count INTEGER,
  content_goals TEXT,
  tone_and_style TEXT,
  outline JSONB DEFAULT '[]'::jsonb, -- Array of outline sections
  required_sections JSONB DEFAULT '[]'::jsonb,
  internal_links JSONB DEFAULT '[]'::jsonb,
  external_references JSONB DEFAULT '[]'::jsonb,
  competitor_examples JSONB DEFAULT '[]'::jsonb,
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  approved_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  approved_at TIMESTAMPTZ,

  -- Content-specific fields
  body JSONB, -- EditorJS content
  storyblok_url TEXT,
  story_id BIGINT,
  draft_story_id BIGINT,
  release_id BIGINT REFERENCES releases(id) ON DELETE SET NULL,
  due_date DATE,
  scheduled_date DATE,
  scheduled_time TIME,
  publish_date TIMESTAMPTZ,
  display_order INTEGER DEFAULT 0,
  seo_metadata JSONB DEFAULT '{}'::jsonb,
  social_metadata JSONB DEFAULT '{}'::jsonb,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- STEP 2: Migrate data from existing tables
-- ============================================================================

-- Migrate ideas
INSERT INTO cp_content (
  title, description, stage, idea_status,
  content_type_id, campaign_id, priority, notes, metadata,
  source, potential_keywords, target_audience, estimated_effort,
  vote_count, votes, rejection_reason, submitted_by, reviewed_by, reviewed_at,
  created_at, updated_at
)
SELECT
  title,
  description,
  'idea',
  COALESCE(status, 'submitted'),
  content_type_id,
  campaign_id,
  COALESCE(priority, 'medium'),
  notes,
  metadata,
  source,
  potential_keywords,
  target_audience,
  estimated_effort,
  COALESCE(vote_count, 0),
  COALESCE(votes, '[]'::jsonb),
  rejection_reason,
  submitted_by,
  reviewed_by,
  reviewed_at,
  created_at,
  updated_at
FROM cp_content_ideas;

-- Migrate briefs
INSERT INTO cp_content (
  title, slug, description, stage, brief_status,
  content_type_id, campaign_id, notes, metadata,
  target_audience, primary_keyword, secondary_keywords, search_intent, target_word_count,
  content_goals, tone_and_style, outline, required_sections,
  internal_links, external_references, competitor_examples,
  created_by, approved_by, approved_at,
  created_at, updated_at
)
SELECT
  title,
  slug,
  summary, -- maps to description
  'brief',
  COALESCE(status, 'draft'),
  content_type_id,
  campaign_id,
  notes,
  metadata,
  target_audience,
  primary_keyword,
  secondary_keywords,
  search_intent,
  target_word_count,
  content_goals,
  tone_and_style,
  outline,
  required_sections,
  internal_links,
  external_references,
  competitor_examples,
  created_by,
  approved_by,
  approved_at,
  created_at,
  updated_at
FROM cp_content_briefs;

-- Migrate content items
INSERT INTO cp_content (
  title, slug, stage, workflow_status_id,
  content_type_id, campaign_id, priority, notes, metadata,
  body, storyblok_url, story_id, draft_story_id, release_id,
  due_date, scheduled_date, scheduled_time, publish_date,
  display_order, seo_metadata, social_metadata,
  created_at, updated_at
)
SELECT
  title,
  slug,
  'content',
  workflow_status_id,
  content_type_id,
  campaign_id,
  COALESCE(priority, 'medium'),
  notes,
  metadata,
  body,
  storyblok_url,
  story_id,
  draft_story_id,
  release_id,
  due_date,
  scheduled_date,
  scheduled_time,
  publish_date,
  COALESCE(display_order, 0),
  seo_metadata,
  social_metadata,
  created_at,
  updated_at
FROM cp_content_items;

-- ============================================================================
-- STEP 3: Create mapping table for old IDs to new IDs
-- ============================================================================

-- Create temporary mapping tables for FK migration
CREATE TEMP TABLE id_mapping_ideas AS
SELECT
  old.id as old_id,
  new.id as new_id
FROM cp_content_ideas old
JOIN cp_content new ON new.stage = 'idea'
  AND new.title = old.title
  AND new.created_at = old.created_at;

CREATE TEMP TABLE id_mapping_briefs AS
SELECT
  old.id as old_id,
  new.id as new_id
FROM cp_content_briefs old
JOIN cp_content new ON new.stage = 'brief'
  AND new.title = old.title
  AND new.created_at = old.created_at;

CREATE TEMP TABLE id_mapping_items AS
SELECT
  old.id as old_id,
  new.id as new_id
FROM cp_content_items old
JOIN cp_content new ON new.stage = 'content'
  AND new.title = old.title
  AND new.created_at = old.created_at;

-- ============================================================================
-- STEP 4: Add content_id column to related tables and migrate FK references
-- ============================================================================

-- cp_content_tags: Add content_id, migrate data, drop old column
ALTER TABLE cp_content_tags ADD COLUMN content_id BIGINT;
UPDATE cp_content_tags t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_content_tags DROP CONSTRAINT IF EXISTS cp_content_tags_content_item_id_fkey;
ALTER TABLE cp_content_tags DROP COLUMN content_item_id;
ALTER TABLE cp_content_tags ADD CONSTRAINT cp_content_tags_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;
ALTER TABLE cp_content_tags ALTER COLUMN content_id SET NOT NULL;

-- cp_content_attachments: Add content_id, migrate data, drop old column
ALTER TABLE cp_content_attachments ADD COLUMN content_id BIGINT;
UPDATE cp_content_attachments t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_content_attachments DROP CONSTRAINT IF EXISTS cp_content_attachments_content_item_id_fkey;
ALTER TABLE cp_content_attachments DROP COLUMN content_item_id;
ALTER TABLE cp_content_attachments ADD CONSTRAINT cp_content_attachments_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_content_links: Add content_id, migrate data, drop old column
ALTER TABLE cp_content_links ADD COLUMN content_id BIGINT;
UPDATE cp_content_links t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_content_links DROP CONSTRAINT IF EXISTS cp_content_links_content_item_id_fkey;
ALTER TABLE cp_content_links DROP COLUMN content_item_id;
ALTER TABLE cp_content_links ADD CONSTRAINT cp_content_links_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_content_assignments: Add content_id, migrate data, drop old column
ALTER TABLE cp_content_assignments ADD COLUMN content_id BIGINT;
UPDATE cp_content_assignments t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_content_assignments DROP CONSTRAINT IF EXISTS cp_content_assignments_content_item_id_fkey;
ALTER TABLE cp_content_assignments DROP COLUMN content_item_id;
ALTER TABLE cp_content_assignments ADD CONSTRAINT cp_content_assignments_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_workflow_transitions: Add content_id, migrate data, drop old column
ALTER TABLE cp_workflow_transitions ADD COLUMN content_id BIGINT;
UPDATE cp_workflow_transitions t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_workflow_transitions DROP CONSTRAINT IF EXISTS cp_workflow_transitions_content_item_id_fkey;
ALTER TABLE cp_workflow_transitions DROP COLUMN content_item_id;
ALTER TABLE cp_workflow_transitions ADD CONSTRAINT cp_workflow_transitions_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_calendar_events: Add content_id, migrate data, drop old column
ALTER TABLE cp_calendar_events ADD COLUMN content_id BIGINT;
UPDATE cp_calendar_events t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_calendar_events DROP CONSTRAINT IF EXISTS cp_calendar_events_content_item_id_fkey;
ALTER TABLE cp_calendar_events DROP COLUMN content_item_id;
ALTER TABLE cp_calendar_events ADD CONSTRAINT cp_calendar_events_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE SET NULL;

-- cp_content_analytics: Add content_id, migrate data, drop old column
ALTER TABLE cp_content_analytics ADD COLUMN content_id BIGINT;
UPDATE cp_content_analytics t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_content_analytics DROP CONSTRAINT IF EXISTS cp_content_analytics_content_item_id_fkey;
ALTER TABLE cp_content_analytics DROP COLUMN content_item_id;
ALTER TABLE cp_content_analytics ADD CONSTRAINT cp_content_analytics_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_best_list_products: Add content_id, migrate data, drop old column
ALTER TABLE cp_best_list_products ADD COLUMN content_id BIGINT;
UPDATE cp_best_list_products t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_best_list_products DROP CONSTRAINT IF EXISTS cp_best_list_products_content_item_id_fkey;
ALTER TABLE cp_best_list_products DROP COLUMN content_item_id;
ALTER TABLE cp_best_list_products ADD CONSTRAINT cp_best_list_products_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- cp_author_assignments (legacy): Add content_id, migrate data, drop old column
ALTER TABLE cp_author_assignments ADD COLUMN content_id BIGINT;
UPDATE cp_author_assignments t
SET content_id = m.new_id
FROM id_mapping_items m
WHERE t.content_item_id = m.old_id;
ALTER TABLE cp_author_assignments DROP CONSTRAINT IF EXISTS cp_author_assignments_content_item_id_fkey;
ALTER TABLE cp_author_assignments DROP COLUMN content_item_id;
ALTER TABLE cp_author_assignments ADD CONSTRAINT cp_author_assignments_content_id_fkey
  FOREIGN KEY (content_id) REFERENCES cp_content(id) ON DELETE CASCADE;

-- ============================================================================
-- STEP 5: Drop old tables
-- ============================================================================

DROP TABLE IF EXISTS cp_content_items CASCADE;
DROP TABLE IF EXISTS cp_content_briefs CASCADE;
DROP TABLE IF EXISTS cp_content_ideas CASCADE;

-- ============================================================================
-- STEP 6: Create indexes on new table
-- ============================================================================

CREATE INDEX idx_cp_content_stage ON cp_content(stage);
CREATE INDEX idx_cp_content_idea_status ON cp_content(idea_status) WHERE stage = 'idea';
CREATE INDEX idx_cp_content_brief_status ON cp_content(brief_status) WHERE stage = 'brief';
CREATE INDEX idx_cp_content_workflow_status ON cp_content(workflow_status_id) WHERE stage = 'content';
CREATE INDEX idx_cp_content_content_type ON cp_content(content_type_id);
CREATE INDEX idx_cp_content_campaign ON cp_content(campaign_id);
CREATE INDEX idx_cp_content_priority ON cp_content(priority);
CREATE INDEX idx_cp_content_due_date ON cp_content(due_date);
CREATE INDEX idx_cp_content_scheduled_date ON cp_content(scheduled_date);
CREATE INDEX idx_cp_content_publish_date ON cp_content(publish_date);
CREATE INDEX idx_cp_content_vote_count ON cp_content(vote_count) WHERE stage = 'idea';
CREATE INDEX idx_cp_content_display_order ON cp_content(display_order) WHERE stage = 'content';
CREATE INDEX idx_cp_content_submitted_by ON cp_content(submitted_by);
CREATE INDEX idx_cp_content_created_by ON cp_content(created_by);
CREATE INDEX idx_cp_content_created_at ON cp_content(created_at);
CREATE INDEX idx_cp_content_metadata_trello ON cp_content USING gin ((metadata->'trello_card_id'));

-- ============================================================================
-- STEP 7: Recreate views
-- ============================================================================

-- Drop existing views
DROP VIEW IF EXISTS cp_calendar_view CASCADE;
DROP VIEW IF EXISTS cp_content_pipeline CASCADE;
DROP VIEW IF EXISTS cp_campaign_summary CASCADE;

-- Recreate cp_campaign_summary view
CREATE VIEW cp_campaign_summary WITH (security_invoker = true) AS
SELECT
  c.id AS campaign_id,
  c.slug,
  c.name,
  c.description,
  c.status,
  c.color,
  c.start_date,
  c.end_date,
  r.name AS release_name,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content') AS total_content_items,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content' AND ws.slug = 'published') AS published_items,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content' AND ws.slug = 'draft') AS draft_items,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content' AND ws.slug IN ('in_review', 'needs_revision')) AS in_progress_items,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content' AND ws.slug = 'scheduled') AS scheduled_items,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'idea') AS total_ideas,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'idea' AND content.idea_status = 'approved') AS approved_ideas,
  COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'brief') AS total_briefs,
  COUNT(DISTINCT ce.id) AS calendar_events,
  CASE
    WHEN COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content') > 0
    THEN ROUND(
      (COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content' AND ws.slug = 'published')::NUMERIC /
       COUNT(DISTINCT content.id) FILTER (WHERE content.stage = 'content')::NUMERIC) * 100, 1)
    ELSE 0
  END AS completion_percentage
FROM cp_campaigns c
LEFT JOIN releases r ON c.release_id = r.id
LEFT JOIN cp_content content ON c.id = content.campaign_id
LEFT JOIN cp_workflow_statuses ws ON content.workflow_status_id = ws.id
LEFT JOIN cp_calendar_events ce ON c.id = ce.campaign_id
GROUP BY c.id, c.slug, c.name, c.description, c.status, c.color, c.start_date, c.end_date, r.name;

-- Recreate cp_content_pipeline view
CREATE VIEW cp_content_pipeline WITH (security_invoker = true) AS
SELECT
  ws.id AS status_id,
  ws.slug AS status_slug,
  ws.name AS status_name,
  ws.color AS status_color,
  ws.display_order,
  ws.is_initial,
  ws.is_terminal,
  COUNT(content.id) AS item_count,
  COUNT(content.id) FILTER (WHERE content.priority = 'urgent') AS urgent_count,
  COUNT(content.id) FILTER (WHERE content.priority = 'high') AS high_priority_count,
  COUNT(content.id) FILTER (WHERE content.due_date < CURRENT_DATE) AS overdue_count,
  ARRAY_AGG(DISTINCT ct.name) FILTER (WHERE ct.name IS NOT NULL) AS content_types
FROM cp_workflow_statuses ws
LEFT JOIN cp_content content ON ws.id = content.workflow_status_id AND content.stage = 'content'
LEFT JOIN cp_content_types ct ON content.content_type_id = ct.id
GROUP BY ws.id, ws.slug, ws.name, ws.color, ws.display_order, ws.is_initial, ws.is_terminal
ORDER BY ws.display_order;

-- Recreate cp_calendar_view
CREATE VIEW cp_calendar_view WITH (security_invoker = true) AS
-- Content items with scheduled dates
SELECT
  'content_item'::text AS item_type,
  content.id AS item_id,
  content.title,
  content.scheduled_date AS start_date,
  content.scheduled_time AS start_time,
  content.scheduled_date AS end_date,
  content.scheduled_time AS end_time,
  false AS all_day,
  ws.color,
  content.priority,
  ct.name AS content_type_name,
  ct.icon AS content_type_icon,
  ws.name AS status_name,
  c.name AS campaign_name,
  content.campaign_id,
  NULL::BIGINT AS calendar_event_id
FROM cp_content content
LEFT JOIN cp_workflow_statuses ws ON content.workflow_status_id = ws.id
LEFT JOIN cp_content_types ct ON content.content_type_id = ct.id
LEFT JOIN cp_campaigns c ON content.campaign_id = c.id
WHERE content.stage = 'content' AND content.scheduled_date IS NOT NULL

UNION ALL

-- Content items with due dates (no scheduled date)
SELECT
  'content_due'::text AS item_type,
  content.id AS item_id,
  content.title || ' (Due)' AS title,
  content.due_date AS start_date,
  NULL::TIME AS start_time,
  content.due_date AS end_date,
  NULL::TIME AS end_time,
  true AS all_day,
  '#EF4444'::VARCHAR AS color,
  content.priority,
  ct.name AS content_type_name,
  ct.icon AS content_type_icon,
  ws.name AS status_name,
  c.name AS campaign_name,
  content.campaign_id,
  NULL::BIGINT AS calendar_event_id
FROM cp_content content
LEFT JOIN cp_workflow_statuses ws ON content.workflow_status_id = ws.id
LEFT JOIN cp_content_types ct ON content.content_type_id = ct.id
LEFT JOIN cp_campaigns c ON content.campaign_id = c.id
WHERE content.stage = 'content'
  AND content.due_date IS NOT NULL
  AND content.scheduled_date IS NULL
  AND ws.is_terminal = false

UNION ALL

-- Calendar events
SELECT
  'calendar_event'::text AS item_type,
  ce.id AS item_id,
  ce.title,
  ce.start_date,
  ce.start_time,
  ce.end_date,
  ce.end_time,
  ce.all_day,
  ce.color,
  NULL::VARCHAR AS priority,
  ce.event_type AS content_type_name,
  CASE ce.event_type
    WHEN 'meeting' THEN 'users'
    WHEN 'deadline' THEN 'alert-circle'
    WHEN 'milestone' THEN 'flag'
    WHEN 'reminder' THEN 'bell'
    ELSE 'calendar'
  END AS content_type_icon,
  ce.event_type AS status_name,
  c.name AS campaign_name,
  ce.campaign_id,
  ce.id AS calendar_event_id
FROM cp_calendar_events ce
LEFT JOIN cp_campaigns c ON ce.campaign_id = c.id;

-- ============================================================================
-- STEP 8: Update RLS policies
-- ============================================================================

-- Enable RLS on cp_content
ALTER TABLE cp_content ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read all content
CREATE POLICY "Authenticated users can view content"
  ON cp_content FOR SELECT
  TO authenticated
  USING (true);

-- Allow editors to insert content
CREATE POLICY "Editors can insert content"
  ON cp_content FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role IN ('admin', 'editor')
    )
  );

-- Allow editors to update content
CREATE POLICY "Editors can update content"
  ON cp_content FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role IN ('admin', 'editor')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role IN ('admin', 'editor')
    )
  );

-- Allow editors to delete content
CREATE POLICY "Editors can delete content"
  ON cp_content FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role IN ('admin', 'editor')
    )
  );

-- ============================================================================
-- STEP 9: Update trigger for updated_at
-- ============================================================================

-- Create or replace the trigger function
CREATE OR REPLACE FUNCTION update_cp_content_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER cp_content_updated_at
  BEFORE UPDATE ON cp_content
  FOR EACH ROW
  EXECUTE FUNCTION update_cp_content_updated_at();

-- ============================================================================
-- STEP 10: Update unique constraints on related tables
-- ============================================================================

-- Update unique constraint on cp_content_tags
ALTER TABLE cp_content_tags DROP CONSTRAINT IF EXISTS cp_content_tags_content_item_id_tag_id_key;
ALTER TABLE cp_content_tags ADD CONSTRAINT cp_content_tags_content_id_tag_id_key
  UNIQUE (content_id, tag_id);

-- Update unique constraint on cp_content_assignments
ALTER TABLE cp_content_assignments DROP CONSTRAINT IF EXISTS cp_content_assignments_content_item_id_user_id_role_key;
ALTER TABLE cp_content_assignments ADD CONSTRAINT cp_content_assignments_content_id_user_id_role_key
  UNIQUE (content_id, user_id, role);

-- Create indexes on the foreign key columns
CREATE INDEX IF NOT EXISTS idx_cp_content_tags_content_id ON cp_content_tags(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_content_attachments_content_id ON cp_content_attachments(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_content_links_content_id ON cp_content_links(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_content_assignments_content_id ON cp_content_assignments(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_workflow_transitions_content_id ON cp_workflow_transitions(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_calendar_events_content_id ON cp_calendar_events(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_content_analytics_content_id ON cp_content_analytics(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_best_list_products_content_id ON cp_best_list_products(content_id);
CREATE INDEX IF NOT EXISTS idx_cp_author_assignments_content_id ON cp_author_assignments(content_id);

-- ============================================================================
-- STEP 11: Recreate dependent objects
-- ============================================================================

-- Recreate cp_author_workload view with new content_id column
CREATE VIEW cp_author_workload WITH (security_invoker = true) AS
SELECT
  a.id AS author_id,
  a.name AS author_name,
  a.slug AS author_slug,
  a.avatar_url,
  COUNT(DISTINCT aa.id) FILTER (WHERE aa.completed_at IS NULL) AS active_assignments,
  COUNT(DISTINCT aa.id) FILTER (WHERE aa.completed_at IS NOT NULL) AS completed_assignments,
  COUNT(DISTINCT aa.id) AS total_assignments,
  MAX(aa.assigned_at) AS latest_assignment,
  ARRAY_AGG(DISTINCT c.title) FILTER (WHERE aa.completed_at IS NULL AND c.title IS NOT NULL) AS active_content_titles
FROM authors a
LEFT JOIN cp_author_assignments aa ON a.id = aa.author_id
LEFT JOIN cp_content c ON aa.content_id = c.id
GROUP BY a.id, a.name, a.slug, a.avatar_url;

-- Recreate the policy on cp_content (replacing the old one on cp_content_items)
CREATE POLICY "Authors can update assigned content"
  ON cp_content FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1
      FROM cp_author_assignments aa
      JOIN authors a ON aa.author_id = a.id
      WHERE aa.content_id = cp_content.id
    )
  );
